{"version":3,"file":"index.js","mappings":";;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../webpack://javascript-action/../../../../usr/local/Cellar/ncc/0.36.1/libexec/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://javascript-action/external node-commonjs \"fs\"","../webpack://javascript-action/webpack/bootstrap","../webpack://javascript-action/webpack/runtime/compat","../webpack://javascript-action/./index.js"],"sourcesContent":[null,"module.exports = require(\"fs\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const core = require('@actions/core')\nconst {\n  ECSClient,\n  DescribeTaskDefinitionCommand,\n  DescribeServicesCommand,\n} = require('@aws-sdk/client-ecs')\nconst { merge, head, omit } = require('lodash')\nconst tmp = require('tmp')\nconst fs = require('fs')\n\nconst IGNORED_TASK_DEFINITION_ATTRIBUTES = [\n  'compatibilities',\n  'taskDefinitionArn',\n  'requiresAttributes',\n  'revision',\n  'status',\n  'registeredAt',\n  'deregisteredAt',\n  'registeredBy'\n]\n\nconst getTaskDefinition = async ({\n  taskDefinition,\n  client,\n}) => {\n  const command = new DescribeTaskDefinitionCommand({\n    taskDefinition,\n    client\n  })\n\n  try {\n    const { taskDefinition } = await client.send(command)\n    return taskDefinition\n  } catch (error) {\n    core.setFailed(error.message)\n  }\n}\n\nconst getECSService = async ({\n  cluster,\n  service,\n  client\n}) => {\n  const command = new DescribeServicesCommand({\n    services: [service],\n    cluster\n  })\n\n  const { services } = await client.send(command)\n  if (services.length < 1) {\n    throw new ReferenceError('Service not found')\n  }\n  return services\n}\n\n\nasync function run() {\n  const aws_region = core.getInput('region')\n  const cluster = core.getInput('cluster-name')\n  const service = core.getInput('service-name')\n  const task = core.getInput('task-name')\n\n  core.info(`Start client with region ${aws_region}`)\n  const client = new ECSClient({ region: aws_region })\n\n  try {\n    if (service !== '') {\n      const services = await getECSService({\n        cluster,\n        service,\n        client\n      })\n\n      const { taskDefinition } = head(services)\n      core.info(`Task definition from service ${taskDefinition}`)\n\n      const taskDef = await getTaskDefinition({\n        taskDefinition,\n        client,\n      })\n\n      core.info(`Task definition from task ${taskDef}`)\n\n      const replacements = core.getInput('replacements') || '{}'\n      const taskDefMerged = merge(taskDef, JSON.parse(replacements))\n      core.info(`Task definition merged ${taskDefMerged}`)\n\n      const newTaskDef = omit(taskDefMerged, IGNORED_TASK_DEFINITION_ATTRIBUTES)\n      core.info(`Task definition merged and cleaned ${newTaskDef}`)\n\n      // create a a file for task def\n      const taskDefFile = tmp.fileSync({\n        tmpdir: process.env.RUNNER_TEMP,\n        prefix: 'task-definition-',\n        postfix: '.json',\n        keep: true,\n        discardDescriptor: true\n      })\n\n      fs.writeFileSync(taskDefFile.name, JSON.stringify(newTaskDef))\n      core.setOutput('taskDef', taskDefFile.name)\n    } else {\n      const taskDef = await getTaskDefinition({\n        taskDefinition: task,\n        client,\n      })\n\n      core.info(`Task definition from task ${taskDef}`)\n\n      const replacements = core.getInput('replacements') || '{}'\n      const taskDefMerged = merge(taskDef, JSON.parse(replacements))\n\n      const newTaskDef = omit(taskDefMerged, IGNORED_TASK_DEFINITION_ATTRIBUTES)\n      core.info(`Task definition merged and cleaned ${newTaskDef}`)\n\n      console.dir(newTaskDef)\n\n      const taskDefFile = tmp.fileSync({\n        tmpdir: process.env.RUNNER_TEMP,\n        prefix: 'task-definition-',\n        postfix: '.json',\n        keep: true,\n        discardDescriptor: true\n      })\n\n      fs.writeFileSync(taskDefFile.name, JSON.stringify(newTaskDef))\n      core.setOutput('taskDef', taskDefFile.name)\n    }\n  } catch (error) {\n    core.setFailed(error.message)\n  }\n}\n\nrun()\n"],"names":[],"sourceRoot":""}